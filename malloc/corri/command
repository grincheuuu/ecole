export LD_LIBRARY_PATH=.

LD_PRELOAD=./libft_malloc_x86_64_Linux.so

test next.c

gcc -o aout next.c -L. -lft_malloc && ./run_linux.sh ./aout
voir plus bas

Library compilation

First we will check that the compilation of the library does
generate the requested files by modifying HOSTTYPE:

$> export HOSTTYPE=Testing
$> make re
********
$> ln -s libft_malloc_Testing.so libft_malloc.so
$> ls -l libft_malloc.so
lrwxrwxrwx 1 ** ** ** ** ** ** libft_malloc.so -> libft_malloc_Testing.so
$>

The Makefile does use HOSTTYPE to define the name of the library
(libft_malloc_$HOSSTYPE.so) and does create a symbolic link
libft_malloc.so pointing towards libft_malloc_$HOSSTYPE.so ?

If that's not the case, the defense stops.

Yes No
Functions export

Check with nm that the library does export the functions malloc,
free, realloc and show_alloc_mem.

$> nm -g libft_malloc.so
0000000000000000 T _free
0000000000000000 T _malloc 
0000000000000000 T _realloc 
0000000000000000 T_show_alloc_mem 
                 U _mmap 
                 U _munmap 
                 U _getpagesize (getpagesize under OSX or sysconf(_SC_PAGESIZE) under linux)
                 U _write  
$>

The functions exported by the library are marked with a T, the
used one with a U (adresses have been replaced by 0, they change
from one library to the next, same as the order of the lines).

If the functions are not exported, defense stops.

Yes No
Feature's testing

Please find the attached (MacOS X or Linux) script that will only modifiy the environment variables while you run a test program.
Malloc test

We are first going to make a first test program that does not
use malloc, so that we have a base to compare to.

Use test0.c file attached in the scale
WARNING: If you are using a linux vm, make sure that you are using the
time binary that you can get with apt (sudo apt install time), else
you won't have access to the -v option.


LINUX:

  $> gcc -o test0 test0.c && /usr/bin/time -v ./test0

We will then add a malloc and write in each allocation to make
sure that the memory page is allocated in physical memory by
MMU. The system will only really allocate the memory of a page
if you write in it, so even if we do a bigger mmap than the
malloc request it won't modify the "page reclaims".

For Linux => Major, Minor

For Mac OS X => page reclaims, page faults

Using the test1.c file given as attachment, run the following tests


LINUX:

  $> gcc -o test1 test1.c && /usr/bin/time -v ./test1

Our test1 program requested 1024 times 1024 bytes, so 1Mbyte. We
can therefore check by doing the difference with the test0
program:

    either between the "maximum resident set size" lines, we obtain a little more than 1Mbyte
    or between the page reclaims lines that we will multiply by the value of getpagesize(3) under OSX or sysconf(_SC_PAGESIZE) under linux.

Let's test now both programs with our library:

LINUX:

$>chmod 777 run_linux.sh

$>./run_linux.sh /usr/bin/time -v ./test0
  ********    
  Major (requiring I/O) page faults: 0
  Minor (reclaiming a frame) page faults: 64
  ********

$>./run_linux.sh /usr/bin/time -v ./test1
  ********    
  Major (requiring I/O) page faults: 0
  Minor (reclaiming a frame) page faults: 323
  ********

Count the number of pages used in addition to the real malloc and adjust the score accordingly:

    less pages than the real malloc, allocated memory is insufficiant: 0
    181 pages and over, malloc works but the overhead is very too big: 1
    between 91 pages and 180 pages, malloc works but the overhead is too big: 2
    between 51 pages and 90 pages, malloc works but the overhead is very big: 3
    between 21 pages and 50 pages than real malloc, malloc works but the overhead is big: 4
    between 0 pages and 20 pages than real malloc, malloc works and the overhead is fine: 5

Rate it from 0 (failed) through 5 (excellent)
Pre-allocated zones

Check inside the source code that the pre-allocated zones for
the different malloc sizes allow to store at least 100 times the
maximum size for this type of zone. Check also that the size of
the zones is a multiple of getpagesize() under OSX or
sysconf(_SC_PAGESIZE) under linux.

If one of these points is missing, click NO.

Yes No
Tests of free

We will simply add a free to our test program:

$> cat test2.c 

We will compare the number of "page reclaims / page faults" to those in test0
and test1. If there are as many or more "page reclaims" than
test1, the free doesn't work.

LINUX:

  $> gcc -o test2 test2.c && ./run_linux.sh /usr/bin/time -v ./test2

Does the free function? (less "page reclaims / page faults" than test1)

Yes No
Quality of the free function

Run test0 and test2. Test2 should not have more than 10 page reclaims
compared to test0.

Yes No
Realloc test

Using test3.c file given as attachment, test the following:

MAC:

$> gcc -o test3 test3.c -L. -lft_malloc && ./run_mac.sh ./test3
Hello world!
Hello world!
$>

LINUX:

$> gcc -o test3 test3.c -L. -lft_malloc && ./run_linux.sh ./test3
Hello world!
Hello world!
$>

The test must print out "Hello world!" two times.

Does it work as expected?

Yes No
Show_alloc_mem test

Using test4.c file given as attachment, test the following:

LINUX:

$> gcc -o test4 test4.c -L. -lft_malloc && ./run_linux.sh ./test4
$>

Does the display corresponds the subject and the TINY/SMALL/LARGE
allocation of the project?

Yes No
Alignement test

Using test5.c file given as attachment, test the following:

LINUX:

$> gcc -o test5 test5.c -L. -lft_malloc && ./run_linux.sh ./test5
$>

You have no alignment errors.


Très bien — je réponds point par point, clairement et sans blabla inutile : d’abord **le `gcc` + usage du script**, puis **ce que fait chaque ligne** du script (`LD_LIBRARY_PATH`, `LD_PRELOAD`, `$@`), et enfin des remarques pratiques (erreurs courantes, bonnes pratiques). Avant ça je couvre rapidement **gradient descent** et **le rôle de `tmp0` / `tmp1`** puisque tu les as demandés aussi.

---

# 1) Gradient descent — explication simple et mathématique

But: je reste bref et concret.

Tu cherches à minimiser la fonction de coût (MSE) :
[
J(\theta_0,\theta_1) = \frac{1}{m}\sum_{i=0}^{m-1}(\hat y_i - y_i)^2
]
avec (\hat y_i = \theta_0 + \theta_1 x_i) (ici `x_i` = mileage, `y_i` = price).

Le **gradient** de J par rapport aux paramètres est :
[
\frac{\partial J}{\partial \theta_0} = \frac{2}{m}\sum(\hat y_i - y_i)
\quad,\quad
\frac{\partial J}{\partial \theta_1} = \frac{2}{m}\sum(\hat y_i - y_i),x_i
]

(La constante 2 dépend de la définition de J ; si tu utilises ( \frac{1}{2m}\sum(\cdot)^2) la 2 disparaît.)

La **mise à jour** par gradient descent :
[
\theta_0 \leftarrow \theta_0 - \alpha \frac{\partial J}{\partial \theta_0}
\qquad
\theta_1 \leftarrow \theta_1 - \alpha \frac{\partial J}{\partial \theta_1}
]
où (\alpha) = `learningRate`.

Interprétation intuitive :

* On calcule l’erreur pour chaque point : (e_i = \hat y_i - y_i).
* On fait la **moyenne** de ces erreurs (et moyenne pondérée par x pour theta1).
* On diminue (\theta_0) et (\theta_1) dans la direction opposée au gradient pour réduire l’erreur globale.

---

### tmp0 / tmp1 — que sont-ils ?

* `tmp0` = (learningRate) × (1/m) × Σ (estimatePrice − price)
  => **c’est la correction appliquée à θ0** (proportionnelle à la moyenne des erreurs).
* `tmp1` = (learningRate) × (1/m) × Σ (estimatePrice − price) × mileage
  => **c’est la correction appliquée à θ1** (moyenne des erreurs pondérées par x).

Donc non, **ils ne sont pas “l’erreur brute”** mais **la quantité de changement** à appliquer aux paramètres (on soustrait tmp pour mettre à jour). Ils mesurent l’ampleur de la correction, pas une « confiance ».

---

# 2) La commande que tu as utilisée

```
gcc -o aout next.c -L. -lft_malloc && ./run_linux.sh ./aout
```

Décomposons :

* `gcc` : lance le compilateur.

* `-o aout` : nomme le binaire produit `aout`.

* `next.c` : fichier source compilé.

* `-L.` : ajoute le répertoire courant (`.`) à la liste des répertoires où le linker cherche les bibliothèques au moment de l’**édition des liens** (link time).

* `-lft_malloc` : demande au linker de lier la bibliothèque `libft_malloc`. Le linker recherche `libft_malloc.so` (shared) ou `libft_malloc.a` (static) dans les répertoires connus (dont `.` à cause de `-L.`).
  → résultat : le binaire `aout` est lié en recherchant cette lib.
  Note : si tu n’as que le `.so`, ça crée une dépendance dynamique au runtime.

* `&& ./run_linux.sh ./aout` : si `gcc` réussit (code 0), exécute `./run_linux.sh ./aout`.

---

# 3) Le script `run_linux.sh` (contenu que tu as montré)

```sh
#!/bin/sh
export LD_LIBRARY_PATH=.
export LD_PRELOAD=libft_malloc.so
$@
```

Explications ligne par ligne :

* `#!/bin/sh`
  → shebang : indique que le script sera exécuté avec `/bin/sh`.

* `export LD_LIBRARY_PATH=.`
  → ajoute le répertoire courant (`.`) à la variable d’environnement `LD_LIBRARY_PATH`.
  **But :** dire au chargeur dynamique (`ld.so`) où chercher les bibliothèques partagées au **runtime** pour satisfaire les dépendances du binaire (par exemple si `aout` a une `DT_NEEDED` pour `libft_malloc.so`). Sans ça, si la lib n’est pas dans un emplacement système, le loader ne la trouvera pas.

  ⚠️ `LD_LIBRARY_PATH` influence **la recherche normale** des bibliothèques partagées.

* `export LD_PRELOAD=libft_malloc.so`
  → demande au linker dynamique de **précharger** et d’insérer `libft_malloc.so` **avant** les autres bibliothèques.
  **But :** forcer l’utilisation des symboles (fonctions) de ta lib partagée *à la place* de ceux de la libc (ex: `malloc`, `free`, `realloc`), afin de tester ton implémentation.
  Important : `LD_PRELOAD` prend normalement un chemin. Mettre juste `libft_malloc.so` fonctionne si le loader trouve le fichier via `LD_LIBRARY_PATH` (ou dans /lib, /usr/lib), sinon il faut mettre le chemin absolu `LD_PRELOAD=/chemin/vers/libft_malloc.so`.

  ⚠️ `LD_PRELOAD` ne fonctionne pas pour les binaires setuid — le noyau/loader l’ignore pour sécurité.

* `$@`
  → **exécute tous les arguments passés au script, exactement comme ils ont été fournis**.
  Si tu lances `./run_linux.sh ./aout arg1 arg2`, `$@` est équivalent à `./aout arg1 arg2` (chaque argument préservé).
  Donc ici ça lance ton exécutable avec les variables d’environnement déjà exportées.

---

# 4) Pourquoi utiliser les deux (`LD_LIBRARY_PATH` + `LD_PRELOAD`) ?

* `LD_LIBRARY_PATH=.` aide le loader à **trouver** `libft_malloc.so` si le nom seul n’est pas suffisante.
* `LD_PRELOAD` force le **préchargement** (et surchargera `malloc`/`free` au runtime).
  Tu peux parfois n’avoir besoin que de `LD_PRELOAD` en donnant un chemin (ex : `LD_PRELOAD=/home/user/malloc/libft_malloc.so ./aout`) — c’est plus sûr.

---

# 5) Bonnes pratiques et pièges courants

* **Chemin absolu** : préfère `export LD_PRELOAD=$PWD/libft_malloc.so` pour éviter erreurs.
* **FPIC** : ton `.so` doit être compilé comme shared PIC :

  ```
  gcc -fPIC -c *.c
  gcc -shared -o libft_malloc.so *.o
  ```

  Sans `-fPIC -shared` tu n’as pas une vraie .so et ça peut échouer.
* **Ne pas appeler la libc depuis ton malloc** : ton implémentation ne doit pas appeler `malloc`/`free`/`printf` internes qui themselves call malloc, sinon boucle infinie.
* **Nom exact** : `-lft_malloc` cherche `libft_malloc.so` ou `libft_malloc.a` — attention aux noms.
* **Setuid** : LD_PRELOAD est ignoré sur binaires setuid (sécurité).
* **Exécutable exécutable** : `chmod +x run_linux.sh` si besoin.
* **Test avec chemin complet** : plutôt que `export LD_PRELOAD=libft_malloc.so`, fais :

  ```
  LD_PRELOAD="$PWD/libft_malloc.so" ./aout
  ```

  ou via ton script : `export LD_PRELOAD=$PWD/libft_malloc.so`.

---

# 6) Fin du script — `$@` vs `exec "$@"`

* `$@` lance la commande en forkant un processus enfant sous le shell (le shell continue ensuite et termine).
* `exec "$@"` remplace le processus shell par la commande — utile si tu veux que le PID reste celui du script (par ex. pour signals) et éviter un processus shell résiduel. Pour un test simple, `$@` suffit.

Exemples :

```sh
# version recommandée
#!/bin/sh
export LD_PRELOAD="$PWD/libft_malloc.so"
exec "$@"
```

Ici `exec` s’assure que les signaux (ctrl-c) vont directement au programme et pas au shell wrapper.

---

# 7) Diagnostic rapide si ça plante (segfault, cannot open, etc.)

* `ls -l libft_malloc.so` — existe-t-il ?
* `readelf -h libft_malloc.so` / `file libft_malloc.so` — est-ce une vraie shared lib ? (ELF, shared)
* `ldd ./aout` — voir si le binaire a des dépendances non résolues (peut échouer si l’exécutable a besoin de la lib que tu fournis).
* `LD_PRELOAD=$PWD/libft_malloc.so ./aout` — tester sans script.
* `export LD_LIBRARY_PATH=$PWD` si le loader ne trouve pas la .so.
* `nm -D libft_malloc.so | grep malloc` — vérifier que les symboles (malloc/free) sont exportés.
* `gcc` link-time : si tu utilises `-lft_malloc` au lien, assure-toi que la lib est compatible; parfois mieux créer binaire sans `-l...` et juste utiliser LD_PRELOAD.

---

# 8) Pourquoi on fait ça dans le projet `malloc` ?

Objectif : **faire exécuter `aout` en utilisant TON implémentation de `malloc` et `free`** pour vérifier comportement, fuites, tests. `LD_PRELOAD` est la façon standard de surcharger des symboles dynamiques à l’exécution sans modifier l’exécutable.

---

Si tu veux, je peux aussi :

* te fournir un **script de test** plus robuste (`run_test.sh`) avec checks (fichier existe, chemins absolus, `exec`),
* t’aider à **vérifier** que ta `.so` exporte bien `malloc/free` et a été compilée avec `-fPIC -shared`,
* expliquer comment **déboguer** un segfault (gdb, backtrace) quand le preload fait crash.

Tu veux que je t’écrive un `run_test.sh` propre et sûr ?


Yes No

